#include "OpFile.h"

// 移入回收站
int OpFile::MoveToBin(LPCWSTR filePnN) {
	std::wstring* path = new std::wstring;
	*path = filePnN;
	//SHFileOperation要求以\0\0结尾，此处首先添加字符a并将其复写为\0实现目的
	*path += L'a';
	(*path)[(*path).length() - 1] = L'\0';

	SHFILEOPSTRUCTW FileOp;
	FileOp.hwnd = NULL;
	FileOp.wFunc = FO_DELETE;
	FileOp.pFrom = path->c_str();
	FileOp.fFlags = FOF_ALLOWUNDO | FOF_NOCONFIRMATION;

	int retn = SHFileOperation(&FileOp);
	delete path;
	return retn;
}

// 以.bak后缀重命名
int OpFile::RenameFile(LPCWSTR dirPath, LPCWSTR filename, LPCWSTR rExt) {
	std::wstring* path = new std::wstring;
	*path = L"\\\\?\\";
	*path += dirPath;
	*path += filename;
	std::wstring* pto = new std::wstring;
	*pto = L"\\\\?\\";
	*pto += dirPath;
	*pto += filename;
	*pto += rExt;

	bool retn = MoveFileW(path->c_str(), pto->c_str());
	delete path;
	delete pto;
	return retn;
}
// 恢复原文件名，去除.bak后缀
int OpFile::RecoverFile(LPCWSTR filePnN) {
	std::wstring* path = new std::wstring;
	*path = L"\\\\?\\";
	*path += filePnN;
	CString tmp(filePnN);
	tmp.Replace(L".bak", L"");
	bool retn = MoveFileW(path->c_str(), tmp);
	delete path;
	return retn;
}

//列出所有的盘符
std::string OpFile::GetDrv() {
	char drvStr[4] = "A:\\";
	unsigned int retn;
	std::string drvList;
	for (int i = 0; i < 26; i++) { //A-Z穷举
		drvStr[0] = 65 + i;
		retn = GetDriveTypeA((LPCSTR)drvStr);
		if (retn != 0 && retn != 1) {
			drvList += drvStr[0];
		}
	}
	return drvList;
}

//遍历文件夹下所有文件和所有子文件夹的文件，回调函数参数为文件所在路径、文件名
void OpFile::TravelPath(LPCWSTR parPth, void (*callback)(LPCWSTR, LPCWSTR, void (*)(LPCWSTR), void (*)(LPCWSTR)), void (*logFunc)(LPCWSTR), void (*errFunc)(LPCWSTR), void (*ongoingFunc)(LPCWSTR)) {
	CString tmpstr(parPth);
	for (int j = 0; j < whitelist.size(); j++) {
		if (tmpstr.Find(whitelist[j]) >= 0) {
			return;
		}
	}
	int cCount = tmpstr.Replace(L"\\", L"\\");
	if (cCount <= 10) {
		ongoingFunc(parPth);
		Sleep(1.5);
	}	
	WIN32_FIND_DATAW ffd;
	HANDLE hFile = INVALID_HANDLE_VALUE;
	hFile = FindFirstFileW(parPth, &ffd);
	if (hFile == INVALID_HANDLE_VALUE) {
		std::wostringstream* wstrerr = new std::wostringstream;
		*wstrerr << L"[-] 无法打开文件夹 " << parPth << " " << OpFile::ErrorHandler(GetLastError());
		errFunc(wstrerr->str().c_str());
		delete wstrerr;
		return;
	}

	//遍历该目录下所有文件
	do {
		if (!wcscmp(ffd.cFileName, L".") || !wcscmp(ffd.cFileName, L".."))
			continue;
		std::wstring* _parPth = new std::wstring;
		*_parPth = parPth; //本次所在子文件夹路径，用于递归传递给自身
		std::wstring* filePth = new std::wstring; //文件所在目录，用于传递给回调函数
		if (ffd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) {
			(*_parPth).pop_back(); //去除最后的*
			*_parPth += ffd.cFileName;
			*_parPth += L"\\*";
			OpFile::TravelPath((*_parPth).c_str(), callback, logFunc, errFunc, ongoingFunc); //递归调用，遍历子文件夹
		}
		else {
			*filePth += parPth;
			(*filePth).pop_back(); //去除最后的*
			(*callback)((*filePth).c_str(), ffd.cFileName, logFunc, errFunc);
		}
		delete _parPth;
		delete filePth;
	} while (FindNextFileW(hFile, &ffd));

	FindClose(hFile);
	return;
}

wchar_t* OpFile::ErrorHandler(LSTATUS error) {
	LPWSTR messageBuffer = nullptr;
	size_t size = FormatMessageW(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS, NULL, error, MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US), (LPWSTR)&messageBuffer, 0, NULL);
	return messageBuffer;
}


unsigned int OpFile::CountFile(LPCWSTR parPth) {
	WIN32_FIND_DATAW ffd;
	HANDLE hFile = INVALID_HANDLE_VALUE;
	unsigned int sum = 1;
	hFile = FindFirstFileW(parPth, &ffd);
	if (hFile == INVALID_HANDLE_VALUE) {
		return sum;
	}
	//遍历该目录下所有文件
	do {
		if (!wcscmp(ffd.cFileName, L".") || !wcscmp(ffd.cFileName, L".."))
			continue;
		std::wstring* _parPth = new std::wstring;
		*_parPth = parPth; //本次所在子文件夹路径，用于递归传递给自身
		std::wstring* filePth = new std::wstring; //文件所在目录，用于传递给回调函数
		if (ffd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) {
			(*_parPth).pop_back(); //去除最后的*
			*_parPth += ffd.cFileName;
			*_parPth += L"\\*";
			sum += OpFile::CountFile((*_parPth).c_str()); //递归调用，遍历子文件夹
		}
		delete _parPth;
		delete filePth;
	} while (FindNextFileW(hFile, &ffd));
	FindClose(hFile);
	return sum;
}