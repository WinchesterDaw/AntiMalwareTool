#include "pch.h"
#include "stdafx.h"
HWND myhwnd;
const wchar_t* malExts3[5] = { L"acad.fas", L"lcm.fas", L"acad.lsp", L"acadapp.lsp", L"acadappp.lsp" };
CString white_path ("./whitelist");
// 全局变量
unsigned int diskCount;
unsigned int diskProgress;
std::vector<wchar_t*> whitelist;
std::vector<LPCWSTR> CADvirus;



//功能函数
void initLog(HWND hwnd) {
	myhwnd = hwnd;
	diskCount = 0;
	diskProgress = 0;
	PostMessage(myhwnd, WM_MY_INILOG_MSG, 0, 0);
}
void outLog(LPCWSTR wstr) {
	CString sCopyData(wstr);
	COPYDATASTRUCT cpd;
	cpd.dwData = 0;
	cpd.cbData = (sCopyData.GetLength() + 1) * sizeof(TCHAR);//多加一个长度，防止乱码
	cpd.lpData = (void*)sCopyData.GetBuffer(cpd.cbData);
	SendMessage(myhwnd, WM_COPYDATA, NULL, (LPARAM)&cpd);
}
void errorLog(LPCWSTR wstr) {
	CString sCopyData(wstr);
	COPYDATASTRUCT cpd;
	cpd.dwData = 1;
	cpd.cbData = (sCopyData.GetLength() + 1) * sizeof(TCHAR);//多加一个长度，防止乱码
	cpd.lpData = (void*)sCopyData.GetBuffer(cpd.cbData);
	SendMessage(myhwnd, WM_COPYDATA, NULL, (LPARAM)&cpd);
}
void ongoingLog(LPCWSTR wstr) {
	CString sCopyData(wstr);
	COPYDATASTRUCT cpd;
	cpd.dwData = 2;
	cpd.cbData = (sCopyData.GetLength() + 1) * sizeof(TCHAR);//多加一个长度，防止乱码
	cpd.lpData = (void*)sCopyData.GetBuffer(cpd.cbData);
	SendMessage(myhwnd, WM_COPYDATA, NULL, (LPARAM)&cpd);
}

void _tInstallPathScan(static bool* tLock) {
	InstallPathScan(&outLog, &errorLog, &ongoingLog);
	PostMessage(myhwnd, WM_MY_PROEND_MSG, 0, 0);
	outLog((wchar_t*)L"[+] CAD安装路径扫描完毕。");
	*tLock = false;
	diskCount = 0;
	diskProgress = 0;
	
}
void _tFullDiskScan(static bool* tLock) {
	FullDiskScan(&outLog, &errorLog, &ongoingLog);
	PostMessage(myhwnd, WM_MY_PROEND_MSG, 0, 0);
	outLog((wchar_t*)L"[+] 全盘扫描完毕。");
	*tLock = false;
	diskCount = 0;
	diskProgress = 0;
}
void KillAllThread(std::vector<HANDLE> hThread) {
	// Lock guiout and guierror to prevent vector object corroption.
	//guiout.clean();
	//guierror.clean();
	for (int i = 0; i < hThread.size(); i++) {
		TerminateThread(hThread[i], 0); // NO GOD PLEASE NO
	}
	hThread.clear();
	// Re-activate guiout and guierror
	//guiout.init();
	//guierror.init();
}

//覆盖式写入文件
void WriteToFile() {
	CStdioFile Wfile(white_path, CFile::modeWrite | CFile::modeCreate); //定义并初始化一个CStdioFile类的对Rfile 
	setlocale(LC_CTYPE, ("chs"));  //中文写入
	if (whitelist.size() == 0) {  //清空文件内容
		Wfile.SetLength(0);
	}
	else {
		CString csExt;  //一行一行的读入字符串
		for (int i = 0; i < whitelist.size(); i++)
		{
			csExt = whitelist[i];
			Wfile.WriteString(csExt + '\n');
		}
	}
	Wfile.Close();
}

//更新白名单
void UpdateWhitelist() {
	CString csExt;
	int nFileLen;
	CStdioFile Rfile(white_path, CFile::modeRead | CFile::modeNoTruncate | CFile::modeCreate); //定义并初始化一个CStdioFile类的对Rfile
	//一行一行的读入字符串
	TCHAR* old_locale = _tcsdup(_tsetlocale(LC_CTYPE, NULL));  // 读入中文
	_tsetlocale(LC_CTYPE, _T("chs"));
	while (Rfile.ReadString(csExt))
	{
		whitelist.push_back(csExt.AllocSysString());
	}
	Rfile.Close();
	_tsetlocale(LC_CTYPE, old_locale);  //释放
	free(old_locale);
}


// 错误信息处理
wchar_t* ErrorHandler(LSTATUS error) {
	// 格式化错误信息，代码来自 https://stackoverflow.com/questions/1387064/how-to-get-the-error-message-from-the-error-code-returned-by-getlasterror
	LPWSTR messageBuffer = nullptr;
	size_t size = FormatMessageW(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS, NULL, error, MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US), (LPWSTR)&messageBuffer, 0, NULL);
	return messageBuffer;
}

// 回调函数
void FileHandler(LPCWSTR dirPath, LPCWSTR filename, void (*logFunc)(LPCWSTR), void (*errFunc)(LPCWSTR)) {
	dirPath = dirPath + 4; //截去\\?\前缀，通过改变指针始地址实现
	for (int i = 0, retn = 0; i < 5; i++) {
		//遍历malExts3查找文件名
		if (!wcscmp(filename, malExts3[i])) {
			retn = OpFile::RenameFile(dirPath, filename, L".bak");
			if (retn) {
				std::wstring* fname = new std::wstring;
				*fname = dirPath;
				*fname += filename;
				*fname += L".bak";
				CADvirus.push_back(fname->c_str());
				std::wostringstream* wstrlog = new std::wostringstream;
				*wstrlog << L"[+] 扫描到可疑文件 " << dirPath << filename;
				logFunc(wstrlog->str().c_str());
				delete wstrlog;
			}
			else {
				std::wostringstream* wstrerr = new std::wostringstream;
				*wstrerr << L"[-] 错误：处理文件 " << dirPath << filename << L" ERROR: " << ErrorHandler(GetLastError());
				errFunc(wstrerr->str().c_str());
				delete wstrerr;
			}
		}
	}
	return;
}

//获取CAD安装路径
std::vector<wchar_t*> GetCADInstallPath(void (*logFunc)(LPCWSTR), void (*errFunc)(LPCWSTR)) {
	std::vector<wchar_t*> paths;
	DWORD Type = REG_SZ;
	for (int i = 0; i < 7; i++) {
		for (int j = 0; j < 3; j++) {
			wchar_t* regPath = new wchar_t[50];
			swprintf_s(regPath, 50, L"SOFTWARE\\Autodesk\\AutoCAD\\R%d.%d\\InstalledProducts", 15 + i, j);
			wchar_t* retn = OpReg::GetRegistryKeyString(HKEY_LOCAL_MACHINE, regPath, &Type, logFunc, errFunc);
			if (retn != NULL) {
				paths.push_back(retn);
				continue;
			}
			delete[] regPath;
		}
	}
	diskCount = paths.size();

	//paths.push_back(L"D:\\邓邓邓邓\\Desktop");

	return paths;
}

//安装路径扫描
void InstallPathScan(void (*logFunc)(LPCWSTR), void (*errFunc)(LPCWSTR), void (*ongoingFunc)(LPCWSTR)) {
	std::vector<wchar_t*> InstalledPaths = GetCADInstallPath(logFunc, errFunc);
	for (int i = 0; i < InstalledPaths.size(); i++) {
		diskProgress++;
		PostMessage(myhwnd, WM_MY_PROGRESS_MSG, 0, 0);
		// 打印
		std::wostringstream* wstrlog = new std::wostringstream;
		*wstrlog << L"[+] 开始安装路径扫描 " << InstalledPaths[i];
		logFunc(wstrlog->str().c_str());
		delete wstrlog;
		logFunc(L"[+] 即将以.bak扩展名重命名可疑文件。");

		size_t pthLen = wcslen(InstalledPaths[i]) + 7;
		wchar_t* scanPth = new wchar_t[pthLen];
		wcscpy_s(scanPth, pthLen, L"\\\\?\\");
		wcscat_s(scanPth, pthLen, InstalledPaths[i]);
		wcscat_s(scanPth, pthLen, L"\\*");
		OpFile::TravelPath(scanPth, &FileHandler, logFunc, errFunc, ongoingFunc); //传入回调函数
		delete[] scanPth;
		
	}
}

//全盘扫描
void FullDiskScan(void (*logFunc)(LPCWSTR), void (*errFunc)(LPCWSTR), void (*ongoingFunc)(LPCWSTR)) {
	std::wstring drvList = std::wstring_convert<std::codecvt_utf8<wchar_t>>().from_bytes(OpFile::GetDrv()); //从char转换wchar_t
	std::wstring tmpPath = L"\\\\?\\A:\\*";
	diskCount = drvList.size();
	for (unsigned int i = 0; i < drvList.size(); i++) {
		diskProgress++;
		PostMessage(myhwnd, WM_MY_PROGRESS_MSG, 0, 0);
		//打印Log
		std::wostringstream* wstrlog = new std::wostringstream;
		*wstrlog << L"[+] 开始全盘扫描 " << drvList[i] << L":\\";
		logFunc(wstrlog->str().c_str());
		delete wstrlog;
		logFunc(L"[+] 即将以.bak扩展名重命名可疑文件。");

		tmpPath[4] = drvList[i];
		tmpPath[5] = L':';
		tmpPath[6] = L'\\';
		tmpPath[7] = L'*';
		tmpPath[8] = L'\0';
		OpFile::TravelPath(tmpPath.c_str(), &FileHandler, logFunc, errFunc, ongoingFunc); //传入回调函数

	}
	return;
}





